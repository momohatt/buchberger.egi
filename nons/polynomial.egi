-- Specify the full path to run this script from another directory
loadFile "/Users/momohatt/egison/buchberger.egi/nons/example.egi"

variable := something

monomial := matcher
  | degree $ as integer with
    | $tgt -> [sum (map snd tgt)]
  | power #$x $ as integer with
    | $tgt -> match tgt as multiset (variable, integer) with
              | (#x, $n) :: _ -> [n]
              | _             -> [0]
  | power $ $ as (variable, integer) with
    | $tgt -> tgt
  | mult #$val $ as monomial with
    | $tgt -> div val tgt
  | $ as multiset (variable, integer) with
    | $tgt -> [tgt]

div divisor dividend :=
  match (divisor, dividend) as
    (list (variable, integer), multiset (variable, integer)) with
  | ([], _) -> [dividend]
  | (($x, $n) :: $r1, (#x, $m & ?(>= n)) :: $r2) ->
      match div r1 r2 as list something with
      | [] -> []
      | $result :: [] -> if n = m then [result]
                                  else [(x, m - n) :: result]
  | _ -> []

assertEqual "degree"
  (match [] as monomial with degree $n -> n)
  0

assertEqual "degree"
  (match [(x, 2), (y, 1)] as monomial with degree $n -> n)
  3

assertEqual "power"
  (matchAll [(x, 2), (y, 1)] as monomial with
   | power $x $n -> (x, n))
   [(x, 2), (y, 1)]

assertEqual "power"
  (match [(x, 2), (y, 1)] as monomial with
   | power #z $n -> n)
  0

assertEqual "mult"
  (match [(x, 2), (y, 1)] as monomial with
   | mult #[(x, 1)] $rem -> rem)
  [(x, 1), (y, 1)]

assertEqual "mult"
  (matchAll [(x, 2), (y, 1)] as monomial with
   | mult #[(x, 3)] $rem -> rem)
  []

polynomial := matcher
  | head #$ord $ $ as (integer, monomial) with
    | $tgt -> [max/fn (\m1 m2 -> ordMonoLex ord (snd m1) (snd m2)) tgt]
  | $ as multiset (integer, monomial) with
    | $tgt -> [tgt]

assertEqual "head"
  (match [(1, [(x, 1)]), (1, [(x, 2)])] as polynomial with
   | head #[x] $n $x -> (n, x))
  (1, [(x, 2)])

-- Lexicographic Ordering
ordMonoLex l m1 m2 :=
  match (l, m1, m2) as (list variable, monomial, monomial) with
  | ([], _, _) -> Equal
  | ($x :: $xs, power #x $n1, power #x $n2) ->
    match compare n1 n2 as ordering with
    | equal -> ordMonoLex xs m1 m2
    | $cmp  -> cmp

-- Graded Lexicographic Ordering
ordMonoGrlex :=
  \match as (list variable, monomial, monomial) with
  | (_, degree $n1, degree (!#n1 & $n2)) -> compare n1 n2
  | ($ord, $m1, $m2) -> ordMonoLex ord m1 m2

assertEqual "ord-mono-lex"
  (ordMonoLex [x, y, z] [(x, 1), (y, 2)] [(y, 3), (z, 2)])
  Greater

assertEqual "ord-mono-lex"
  (ordMonoLex [x, y, z] [(x, 2), (y, 3), (z, 3)] [(x, 2), (y, 1), (z, 5)])
  Greater

assertEqual "ord-mono-grlex"
  (ordMonoGrlex [x, y, z] [(x, 1), (y, 3), (z, 2)] [(x, 4), (y, 1)])
  Greater

assertEqual "ord-mono-grlex"
  (ordMonoGrlex [x, y, z] [(x, 1), (y, 3), (z, 2)] [(x, 1), (y, 1), (z, 4)])
  Greater

nonHeads poly ord :=
  match poly as polynomial with
  | head #ord $c $mono -> deleteFirst (c, mono) poly

assertEqual "non-heads"
  (nonHeads [(1, [(x, 2)]), (1, [(y, 1)]), (1, [])] [x, y])
  [(1, [(y, 1)]), (1, [])]

negate :=
  \matchAll as polynomial with
  | ($c, $mono) :: _ -> (neg c, mono)

multMono :=
  \matchAll as (monomial, monomial) with
  | (($x, $n) :: _, (#x, $m) :: _) -> (x, n + m)
  | (($x, $n) :: _, !((#x, _) :: _)) -> (x, n)
  | {(@, ($x, $n) :: _), !((#x, _) :: _)} -> (x, n)

assertEqual "mult-mono"
  (multMono [(x, 1), (y, 2)] [(y, 1), (z, 2)])
  [(y, 3), (x, 1), (z, 2)]

assertEqual "mult-mono"
  (multMono [] [(y, 1), (z, 2)])
  [(y, 1), (z, 2)]

mult :=
  \matchAll as ((integer, monomial), polynomial) with
  | (($c1, $m1), ($c2, $m2) :: _) -> (c1 * c2, multMono m1 m2)

assertEqual "mult"
  (mult (2, [(x, 1)]) [(2, [(x, 1), (y, 1)]), (-1, [(x, 1)])])
  [(4, [(x, 2), (y, 1)]), (-2, [(x, 2)])]

plus :=
  \matchAll as (polynomial, polynomial) with
  | (($c1, $m1) :: _, !((_, #m1) :: _)) -> (c1, m1)
  | (($c1, $m1) :: _, (!#(neg c1) & $c2, #m1) :: _) -> (c1 + c2, m1)
  | {(@, ($c2, $m2) :: _), !((_, #m2) :: _)} -> (c2, m2)

assertEqual "plus"
  (plus [(2, [x, y]), (-1, [x])] [(1, [x, y]), (-1, [y])])
  [(-1, [x]), (3, [x, y]), (-1, [y])]

showMono mono :=
  S.intercalate " "
    (matchAll mono as monomial with
      | power $x $n -> if n = 1 then show x else S.concat [show x, "^", show n]
      | [] -> "1")

showCoeffMono c x := match (c, x) as (integer, monomial) with
    | (#1,     []) -> "+ 1"
    | (#(-1),  []) -> "- 1"
    | (?(> 0), []) -> S.append "+ " (show c)
    | (?(< 0), []) -> S.append "- " (show (neg c))
    | (#1,     $x) -> S.append "+ " (showMono x)
    | (#(-1),  $x) -> S.append "- " (showMono x)
    | (?(> 0), $x) -> S.concat ["+ ", show c, showMono x]
    | (?(< 0), $x) -> S.concat ["- " , show (neg c), showMono x]

showCoeffMonoHead c x := match (c, x) as (integer, monomial) with
    | (#1,     []) -> "1"
    | (#(-1),  []) -> "- 1"
    | (?(> 0), []) -> show c
    | (?(< 0), []) -> S.append "- " (show (neg c))
    | (#1,     $x) -> showMono x
    | (#(-1),  $x) -> S.append "- " (showMono x)
    | (?(> 0), $x) -> S.append (show c) (showMono x)
    | (?(< 0), $x) -> S.concat ["- " , show (neg c), showMono x]

showPoly :=
  \match as list (integer, monomial) with
    | [] -> "0"
    | $x :: $xs ->
      let first := showCoeffMonoHead x
       in S.intercalate " " (first :: map showCoeffMono xs)

colShow/fn show set :=
  S.concat ["{", S.intercalate ",  " (map show set), "}"]

showPolys x :=
  colShow/fn show-poly x

debug/fn :=
  macro show x ->
    io do print (show x)
          return x
